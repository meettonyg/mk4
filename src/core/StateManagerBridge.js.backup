/**
 * State Manager Migration Bridge
 * 
 * Provides backward compatibility during transition from old StateManager 
 * to new EnhancedStateManager with reducer pattern
 * 
 * @file StateManagerBridge.js
 */

import { EnhancedStateManager } from './EnhancedStateManager.js';
import ACTION_TYPES from '../constants/actionTypes.js';

/**
 * Bridge class that provides backward compatibility
 * Maps old setState() calls to new dispatch() pattern
 */
export class StateManagerBridge extends EnhancedStateManager {
    constructor(initialState = {}) {
        super(initialState);
        
        // Track deprecated method usage for migration
        this.deprecationWarnings = new Set();
        
        console.log('✅ State Manager Bridge initialized - backward compatibility enabled');
    }
    
    /**
     * DEPRECATED: Legacy setState method
     * Maps to new dispatch pattern for backward compatibility
     */
    setState(updates) {
        this.logDeprecation('setState', 'dispatch with SET_STATE action');
        
        // Handle different update patterns from legacy code
        if (updates.components !== undefined || 
            updates.layout !== undefined || 
            updates.sections !== undefined ||
            updates.globalSettings !== undefined) {
            // Partial state update
            this.dispatch({
                type: ACTION_TYPES.MERGE_STATE,
                payload: updates
            });
        } else {
            // Assume it's a complete state replacement
            this.dispatch({
                type: ACTION_TYPES.SET_STATE,
                payload: updates
            });
        }
    }
    
    /**
     * DEPRECATED: Legacy direct component mutation
     * Maps to proper action dispatch
     */
    setComponents(components) {
        this.logDeprecation('setComponents', 'dispatch with proper component actions');
        
        // Clear existing components and add new ones
        this.dispatch({ type: ACTION_TYPES.CLEAR_ALL_COMPONENTS });
        
        Object.entries(components).forEach(([id, component]) => {
            this.dispatch({
                type: ACTION_TYPES.ADD_COMPONENT,
                payload: { ...component, id }
            });
        });
    }
    
    /**
     * Legacy method mapping for compatibility
     */
    applyTransaction(transaction) {
        this.logDeprecation('applyTransaction', 'dispatch');
        
        // Map old transaction format to new action format
        const action = this.mapTransactionToAction(transaction);
        if (action) {
            this.dispatch(action);
        }
    }
    
    /**
     * Map old transaction format to new action format
     */
    mapTransactionToAction(transaction) {
        const mapping = {
            'ADD_COMPONENT': ACTION_TYPES.ADD_COMPONENT,
            'REMOVE_COMPONENT': ACTION_TYPES.REMOVE_COMPONENT,
            'UPDATE_COMPONENT': ACTION_TYPES.UPDATE_COMPONENT,
            'MOVE_COMPONENT': ACTION_TYPES.MOVE_COMPONENT,
            'SET_LAYOUT': ACTION_TYPES.SET_LAYOUT,
            'SET_STATE': ACTION_TYPES.SET_STATE,
            'UPDATE_GLOBAL_SETTINGS': ACTION_TYPES.UPDATE_GLOBAL_SETTINGS,
            'UPDATE_SECTIONS': ACTION_TYPES.UPDATE_SECTIONS,
            'ADD_SECTION': ACTION_TYPES.ADD_SECTION,
            'SET_THEME': ACTION_TYPES.SET_THEME
        };
        
        const actionType = mapping[transaction.type];
        if (!actionType) {
            console.warn(`Unknown transaction type: ${transaction.type}`);
            return null;
        }
        
        return {
            type: actionType,
            payload: transaction.payload
        };
    }
    
    /**
     * Legacy batch update methods
     */
    startBatchUpdate() {
        this.logDeprecation('startBatchUpdate', 'startBatch');
        return this.startBatch();
    }
    
    endBatchUpdate() {
        this.logDeprecation('endBatchUpdate', 'endBatch');
        return this.endBatch();
    }
    
    /**
     * Legacy subscribe method with different signature
     */
    subscribeGlobal(callback) {
        this.logDeprecation('subscribeGlobal', 'subscribe');
        return this.subscribe(callback);
    }
    
    /**
     * Legacy method for WordPress integration
     */
    initializeAfterSystems() {
        console.log('🔄 Initializing state manager with WordPress data...');
        
        // Load from WordPress data if available
        if (window.gmkbData) {
            let initialState = {};
            
            // Check for saved state in WordPress data
            if (window.gmkbData.saved_state) {
                initialState = window.gmkbData.saved_state;
            } else if (window.gmkbData.saved_components) {
                // Convert legacy saved_components format
                const components = {};
                window.gmkbData.saved_components.forEach(comp => {
                    if (comp && comp.id) {
                        components[comp.id] = comp;
                    }
                });
                
                initialState = {
                    components,
                    layout: window.gmkbData.saved_components.map(c => c.id),
                    globalSettings: window.gmkbData.global_settings || {}
                };
            }
            
            // Apply initial state
            if (Object.keys(initialState).length > 0) {
                this.dispatch({
                    type: ACTION_TYPES.SET_STATE,
                    payload: initialState
                });
                console.log(`✅ Loaded ${Object.keys(initialState.components || {}).length} components from WordPress`);
            }
        }
        
        // Also try loading from localStorage as fallback
        if (Object.keys(this.state.components).length === 0) {
            this.loadFromStorage();
        }
        
        // Dispatch ready event for compatibility
        document.dispatchEvent(new CustomEvent('gmkb:state-manager:ready', {
            detail: {
                stateManager: this,
                source: 'StateManagerBridge',
                timestamp: Date.now(),
                componentCount: Object.keys(this.state.components).length
            }
        }));
        
        return Promise.resolve();
    }
    
    /**
     * Legacy getInitialState method
     */
    getInitialState() {
        this.logDeprecation('getInitialState', 'getState');
        return this.getState();
    }
    
    /**
     * Legacy notification method
     */
    notifySubscribers() {
        this.logDeprecation('notifySubscribers', 'automatic notification on dispatch');
        this.notify();
    }
    
    /**
     * Track and log deprecation warnings
     */
    logDeprecation(oldMethod, newMethod) {
        const key = `${oldMethod}->${newMethod}`;
        if (!this.deprecationWarnings.has(key)) {
            this.deprecationWarnings.add(key);
            console.warn(
                `⚠️ DEPRECATED: ${oldMethod}() is deprecated. Use ${newMethod} instead.`,
                '\n',
                'See migration guide for details.'
            );
        }
    }
    
    /**
     * Get migration report
     */
    getMigrationReport() {
        const report = {
            deprecatedMethodsUsed: Array.from(this.deprecationWarnings),
            totalWarnings: this.deprecationWarnings.size,
            recommendation: this.deprecationWarnings.size > 0 
                ? 'Update code to use new dispatch pattern'
                : 'No deprecated methods detected'
        };
        
        console.group('📊 State Manager Migration Report');
        console.log('Deprecated Methods Used:', report.deprecatedMethodsUsed);
        console.log('Total Warnings:', report.totalWarnings);
        console.log('Recommendation:', report.recommendation);
        console.groupEnd();
        
        return report;
    }
}

/**
 * Factory function to create appropriate state manager
 * based on migration flag
 */
export function createStateManager(initialState = {}, useBridge = true) {
    if (useBridge) {
        console.log('🌉 Creating State Manager with backward compatibility bridge');
        return new StateManagerBridge(initialState);
    } else {
        console.log('🚀 Creating pure Enhanced State Manager (no backward compatibility)');
        return new EnhancedStateManager(initialState);
    }
}

// Export as default
export default StateManagerBridge;
