/**
 * Performance Optimization Utility for Vue Media Kit Builder
 * Provides virtual scrolling, lazy loading, and performance monitoring
 */

import { ref, computed, onMounted, onUnmounted, nextTick } from 'vue';

/**
 * Virtual Scrolling Composable
 * Use for large lists of components to maintain performance
 */
export function useVirtualScrolling(items, itemHeight = 100, containerHeight = 600) {
    const scrollTop = ref(0);
    const containerRef = ref(null);
    
    const visibleRange = computed(() => {
        const start = Math.floor(scrollTop.value / itemHeight);
        const visibleCount = Math.ceil(containerHeight / itemHeight);
        const end = Math.min(start + visibleCount + 5, items.value.length); // Buffer of 5 items
        
        return {
            start: Math.max(0, start - 2), // Buffer before
            end,
            visibleItems: items.value.slice(Math.max(0, start - 2), end)
        };
    });
    
    const totalHeight = computed(() => items.value.length * itemHeight);
    
    const offsetY = computed(() => visibleRange.value.start * itemHeight);
    
    const onScroll = (event) => {
        scrollTop.value = event.target.scrollTop;
    };
    
    return {
        containerRef,
        visibleRange,
        totalHeight,
        offsetY,
        onScroll
    };
}\n\n/**\n * Lazy Loading Composable\n * Delay loading of heavy components until they're needed\n */\nexport function useLazyLoading(threshold = 0.1) {\n    const observer = ref(null);\n    const isVisible = ref(false);\n    const targetRef = ref(null);\n    \n    onMounted(() => {\n        if (window.IntersectionObserver && targetRef.value) {\n            observer.value = new IntersectionObserver(\n                ([entry]) => {\n                    if (entry.isIntersecting) {\n                        isVisible.value = true;\n                        // Stop observing once visible\n                        observer.value?.unobserve(targetRef.value);\n                    }\n                },\n                { threshold }\n            );\n            \n            observer.value.observe(targetRef.value);\n        } else {\n            // Fallback: immediately visible\n            isVisible.value = true;\n        }\n    });\n    \n    onUnmounted(() => {\n        if (observer.value && targetRef.value) {\n            observer.value.unobserve(targetRef.value);\n        }\n    });\n    \n    return {\n        targetRef,\n        isVisible\n    };\n}\n\n/**\n * Performance Monitoring Composable\n * Track component render times and performance metrics\n */\nexport function usePerformanceMonitoring(componentName) {\n    const renderStartTime = ref(0);\n    const renderTimes = ref([]);\n    const isMonitoring = ref(false);\n    \n    const startRender = () => {\n        if (!window.performance) return;\n        renderStartTime.value = performance.now();\n        isMonitoring.value = true;\n    };\n    \n    const endRender = () => {\n        if (!window.performance || !isMonitoring.value) return;\n        \n        const endTime = performance.now();\n        const renderTime = endTime - renderStartTime.value;\n        \n        renderTimes.value.push({\n            component: componentName,\n            time: renderTime,\n            timestamp: Date.now()\n        });\n        \n        // Keep only last 100 measurements\n        if (renderTimes.value.length > 100) {\n            renderTimes.value.shift();\n        }\n        \n        isMonitoring.value = false;\n        \n        // Warn about slow renders\n        if (renderTime > 16.67) { // > 1 frame at 60fps\n            console.warn(`⚠️ Slow render: ${componentName} took ${renderTime.toFixed(2)}ms`);\n        }\n    };\n    \n    const averageRenderTime = computed(() => {\n        if (renderTimes.value.length === 0) return 0;\n        const sum = renderTimes.value.reduce((acc, item) => acc + item.time, 0);\n        return sum / renderTimes.value.length;\n    });\n    \n    const getPerformanceReport = () => {\n        return {\n            component: componentName,\n            totalRenders: renderTimes.value.length,\n            averageTime: averageRenderTime.value,\n            slowRenders: renderTimes.value.filter(r => r.time > 16.67).length,\n            recentRenders: renderTimes.value.slice(-10)\n        };\n    };\n    \n    return {\n        startRender,\n        endRender,\n        averageRenderTime,\n        getPerformanceReport\n    };\n}\n\n/**\n * Debounced Reactive Composable\n * Debounce reactive updates to prevent excessive re-renders\n */\nexport function useDebouncedRef(initialValue, delay = 300) {\n    const immediate = ref(initialValue);\n    const debounced = ref(initialValue);\n    const timeoutId = ref(null);\n    \n    const updateDebounced = (newValue) => {\n        immediate.value = newValue;\n        \n        if (timeoutId.value) {\n            clearTimeout(timeoutId.value);\n        }\n        \n        timeoutId.value = setTimeout(() => {\n            debounced.value = newValue;\n        }, delay);\n    };\n    \n    onUnmounted(() => {\n        if (timeoutId.value) {\n            clearTimeout(timeoutId.value);\n        }\n    });\n    \n    return {\n        immediate,\n        debounced,\n        update: updateDebounced\n    };\n}\n\n/**\n * Component Cache Composable\n * Cache expensive component calculations\n */\nexport function useComponentCache(maxSize = 50) {\n    const cache = ref(new Map());\n    \n    const get = (key) => {\n        const item = cache.value.get(key);\n        if (item) {\n            // Move to end (LRU)\n            cache.value.delete(key);\n            cache.value.set(key, item);\n            return item;\n        }\n        return null;\n    };\n    \n    const set = (key, value) => {\n        // Remove oldest if at capacity\n        if (cache.value.size >= maxSize) {\n            const firstKey = cache.value.keys().next().value;\n            cache.value.delete(firstKey);\n        }\n        \n        cache.value.set(key, value);\n    };\n    \n    const clear = () => {\n        cache.value.clear();\n    };\n    \n    const has = (key) => {\n        return cache.value.has(key);\n    };\n    \n    return {\n        get,\n        set,\n        clear,\n        has,\n        size: computed(() => cache.value.size)\n    };\n}\n\n/**\n * Image Lazy Loading with Intersection Observer\n */\nexport function useImageLazyLoading() {\n    const imageRefs = ref([]);\n    const observer = ref(null);\n    \n    const addImage = (imgRef) => {\n        if (imgRef && !imageRefs.value.includes(imgRef)) {\n            imageRefs.value.push(imgRef);\n            observer.value?.observe(imgRef);\n        }\n    };\n    \n    const removeImage = (imgRef) => {\n        const index = imageRefs.value.indexOf(imgRef);\n        if (index > -1) {\n            imageRefs.value.splice(index, 1);\n            observer.value?.unobserve(imgRef);\n        }\n    };\n    \n    onMounted(() => {\n        if (window.IntersectionObserver) {\n            observer.value = new IntersectionObserver(\n                (entries) => {\n                    entries.forEach((entry) => {\n                        if (entry.isIntersecting) {\n                            const img = entry.target;\n                            const dataSrc = img.getAttribute('data-src');\n                            \n                            if (dataSrc) {\n                                img.src = dataSrc;\n                                img.removeAttribute('data-src');\n                                img.classList.remove('lazy');\n                                img.classList.add('loaded');\n                            }\n                            \n                            observer.value?.unobserve(img);\n                        }\n                    });\n                },\n                { threshold: 0.1 }\n            );\n        }\n    });\n    \n    onUnmounted(() => {\n        if (observer.value) {\n            imageRefs.value.forEach(img => observer.value?.unobserve(img));\n        }\n    });\n    \n    return {\n        addImage,\n        removeImage\n    };\n}\n\n/**\n * Bundle Size Analyzer\n * Development tool to analyze component bundle sizes\n */\nexport function analyzeBundleSize() {\n    if (process.env.NODE_ENV !== 'development') return;\n    \n    const componentSizes = new Map();\n    \n    const measureComponent = async (componentName, loadFunction) => {\n        const startTime = performance.now();\n        const startMemory = performance.memory?.usedJSHeapSize || 0;\n        \n        const component = await loadFunction();\n        \n        const endTime = performance.now();\n        const endMemory = performance.memory?.usedJSHeapSize || 0;\n        \n        const metrics = {\n            loadTime: endTime - startTime,\n            memoryDelta: endMemory - startMemory,\n            component\n        };\n        \n        componentSizes.set(componentName, metrics);\n        \n        console.log(`📦 ${componentName}: ${metrics.loadTime.toFixed(2)}ms load, ${(metrics.memoryDelta / 1024).toFixed(2)}KB memory`);\n        \n        return component;\n    };\n    \n    const getReport = () => {\n        const report = Array.from(componentSizes.entries()).map(([name, metrics]) => ({\n            name,\n            loadTime: metrics.loadTime,\n            memoryUsage: metrics.memoryDelta\n        }));\n        \n        report.sort((a, b) => b.loadTime - a.loadTime);\n        \n        console.table(report);\n        return report;\n    };\n    \n    return {\n        measureComponent,\n        getReport\n    };\n}\n\n/**\n * Global Performance Monitor\n * Singleton to track overall application performance\n */\nclass GlobalPerformanceMonitor {\n    constructor() {\n        this.metrics = {\n            componentRenders: [],\n            storeUpdates: [],\n            apiCalls: [],\n            memoryUsage: []\n        };\n        \n        this.isMonitoring = false;\n        this.intervalId = null;\n    }\n    \n    start() {\n        if (this.isMonitoring) return;\n        \n        this.isMonitoring = true;\n        console.log('🚀 Performance monitoring started');\n        \n        // Memory monitoring\n        this.intervalId = setInterval(() => {\n            if (performance.memory) {\n                this.metrics.memoryUsage.push({\n                    timestamp: Date.now(),\n                    used: performance.memory.usedJSHeapSize,\n                    total: performance.memory.totalJSHeapSize,\n                    limit: performance.memory.jsHeapSizeLimit\n                });\n                \n                // Keep only last 100 measurements\n                if (this.metrics.memoryUsage.length > 100) {\n                    this.metrics.memoryUsage.shift();\n                }\n            }\n        }, 5000); // Every 5 seconds\n    }\n    \n    stop() {\n        this.isMonitoring = false;\n        if (this.intervalId) {\n            clearInterval(this.intervalId);\n        }\n        console.log('⏹️ Performance monitoring stopped');\n    }\n    \n    recordRender(componentName, time) {\n        this.metrics.componentRenders.push({\n            component: componentName,\n            time,\n            timestamp: Date.now()\n        });\n        \n        // Keep only last 1000 renders\n        if (this.metrics.componentRenders.length > 1000) {\n            this.metrics.componentRenders.shift();\n        }\n    }\n    \n    recordStoreUpdate(action, time) {\n        this.metrics.storeUpdates.push({\n            action,\n            time,\n            timestamp: Date.now()\n        });\n        \n        if (this.metrics.storeUpdates.length > 500) {\n            this.metrics.storeUpdates.shift();\n        }\n    }\n    \n    recordApiCall(endpoint, time, success = true) {\n        this.metrics.apiCalls.push({\n            endpoint,\n            time,\n            success,\n            timestamp: Date.now()\n        });\n        \n        if (this.metrics.apiCalls.length > 200) {\n            this.metrics.apiCalls.shift();\n        }\n    }\n    \n    getReport() {\n        const now = Date.now();\n        const last5Minutes = now - (5 * 60 * 1000);\n        \n        const recentRenders = this.metrics.componentRenders.filter(r => r.timestamp > last5Minutes);\n        const recentUpdates = this.metrics.storeUpdates.filter(u => u.timestamp > last5Minutes);\n        const recentApiCalls = this.metrics.apiCalls.filter(a => a.timestamp > last5Minutes);\n        \n        const report = {\n            summary: {\n                totalRenders: this.metrics.componentRenders.length,\n                totalStoreUpdates: this.metrics.storeUpdates.length,\n                totalApiCalls: this.metrics.apiCalls.length,\n                currentMemory: performance.memory ? (performance.memory.usedJSHeapSize / 1024 / 1024).toFixed(2) + 'MB' : 'N/A'\n            },\n            recent: {\n                renders: recentRenders.length,\n                storeUpdates: recentUpdates.length,\n                apiCalls: recentApiCalls.length,\n                averageRenderTime: recentRenders.length > 0 \n                    ? (recentRenders.reduce((sum, r) => sum + r.time, 0) / recentRenders.length).toFixed(2)\n                    : 0\n            },\n            slowComponents: recentRenders\n                .filter(r => r.time > 16.67)\n                .reduce((acc, r) => {\n                    acc[r.component] = (acc[r.component] || 0) + 1;\n                    return acc;\n                }, {}),\n            memoryTrend: this.metrics.memoryUsage.slice(-10)\n        };\n        \n        return report;\n    }\n    \n    logReport() {\n        const report = this.getReport();\n        console.group('📊 Performance Report');\n        console.table(report.summary);\n        console.table(report.recent);\n        if (Object.keys(report.slowComponents).length > 0) {\n            console.warn('Slow components detected:', report.slowComponents);\n        }\n        console.groupEnd();\n    }\n}\n\n// Export singleton instance\nexport const performanceMonitor = new GlobalPerformanceMonitor();\n\n// Auto-start in development\nif (process.env.NODE_ENV === 'development') {\n    performanceMonitor.start();\n}\n\n// Expose to window for debugging\nif (typeof window !== 'undefined') {\n    window.gmkbPerformance = performanceMonitor;\n}\n\nexport default {\n    useVirtualScrolling,\n    useLazyLoading,\n    usePerformanceMonitoring,\n    useDebouncedRef,\n    useComponentCache,\n    useImageLazyLoading,\n    analyzeBundleSize,\n    performanceMonitor\n};