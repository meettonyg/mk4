/**
 * @file gmkb-main.js
 * @description GMKB Core Namespace & Event Bus - Pure Event-Driven Architecture
 * @version 3.0.0 - PHASE 3 ULTIMATE
 * 
 * PHASE 3 ULTIMATE ENHANCEMENTS:
 * ‚úÖ Pure event-driven architecture with ZERO polling/timeouts
 * ‚úÖ Advanced Event Bus with event sourcing and replay
 * ‚úÖ Real-time system health monitoring and analytics
 * ‚úÖ Predictive failure detection and prevention
 * ‚úÖ Advanced cross-system coordination
 * ‚úÖ Performance optimization with load time tracking
 * ‚úÖ Event streaming for zero-latency initialization
 */

(function(window) {
    'use strict';
    
    // PHASE 3: Ultimate execution tracking with advanced monitoring
    console.log('üöÄ PHASE 3: gmkb-main.js starting ULTIMATE pure event-driven execution...');
    console.log('üöÄ PHASE 3: DOM readyState:', document.readyState);
    console.log('üöÄ PHASE 3: WordPress coordination:', !!window.gmkbWordPressCoordination);
    console.log('üöÄ PHASE 3: Advanced monitoring enabled:', !!window.gmkbAdvancedMonitoring);
    console.log('üöÄ PHASE 3: Performance tracking active:', performance.now());
    
    // PHASE 3: Performance tracking
    window.gmkbPhase3StartTime = performance.now();

    // ROOT FIX: Enhanced multiple initialization protection
    if (window.GMKB) {
        console.warn('‚ö†Ô∏è ROOT FIX: GMKB already initialized - checking completeness');
        
        // ROOT FIX: Validate existing GMKB is complete
        if (window.GMKB.initializer && window.GMKB.ready && window.GMKB.dispatch) {
            console.log('‚úÖ ROOT FIX: Existing GMKB is complete - using existing instance');
            return;
        } else {
            console.warn('‚ö†Ô∏è ROOT FIX: Existing GMKB is incomplete - reinitializing');
            // Allow reinitialization of incomplete GMKB
        }
    }

    /**
     * PHASE 3: Ultimate GMKB Core Namespace - Pure Event-Driven Architecture
     */
    const GMKB = {
        // System registry for tracking loaded systems
        systems: {},
        
        // Event listeners storage
        _eventListeners: new Map(),
        
        // Event queue for early events
        _eventQueue: [],
        
        // PHASE 3: Advanced Event Bus with event sourcing
        _advancedEventBus: {
            events: new Map(),
            eventHistory: [],
            eventSourceEnabled: true,
            maxHistorySize: 1000,
            eventStreams: new Map(),
            eventHandlers: new Map(),
            eventMetrics: {
                totalEvents: 0,
                eventsPerSecond: 0,
                lastEventTime: 0,
                eventLatency: []
            }
        },
        
        /**
         * PHASE 3: Advanced Event Bus - Event sourcing and recording
         */
        _recordEvent(event) {
            // Add to event history
            this._advancedEventBus.eventHistory.push({
                ...event,
                recordedAt: performance.now()
            });
            
            // Maintain history size limit
            if (this._advancedEventBus.eventHistory.length > this._advancedEventBus.maxHistorySize) {
                this._advancedEventBus.eventHistory = this._advancedEventBus.eventHistory.slice(-this._advancedEventBus.maxHistorySize);
            }
            
            // Update event metrics
            this._advancedEventBus.eventMetrics.totalEvents++;
            this._advancedEventBus.eventMetrics.lastEventTime = Date.now();
        },
        
        /**
         * PHASE 3: Predictive pattern analysis
         */
        _analyzePredictivePattern(event) {
            if (!this._predictiveSystem.enabled) return;
            
            const pattern = {
                eventName: event.name,
                source: event.source,
                timestamp: Date.now(),
                context: this._getSystemContext()
            };
            
            // Store pattern
            const patternKey = `${event.name}_${event.source}`;
            if (!this._predictiveSystem.patterns.has(patternKey)) {
                this._predictiveSystem.patterns.set(patternKey, []);
            }
            this._predictiveSystem.patterns.get(patternKey).push(pattern);
            
            // Analyze for anomalies
            this._detectAnomalies(patternKey, pattern);
        },
        
        /**
         * PHASE 3: Get current system context for analysis
         */
        _getSystemContext() {
            return {
                memoryUsage: this._getMemoryUsage(),
                eventQueueSize: this._eventQueue.length,
                registeredSystems: this._initializationState.systemsRegistered.size,
                listenerCount: this._eventListeners.size,
                healthStatus: this._systemHealth.status,
                uptime: Date.now() - this._systemHealth.startTime
            };
        },
        
        /**
         * PHASE 3: Memory usage tracking
         */
        _getMemoryUsage() {
            if (performance.memory) {
                return {
                    used: performance.memory.usedJSHeapSize,
                    total: performance.memory.totalJSHeapSize,
                    limit: performance.memory.jsHeapSizeLimit
                };
            }
            return { used: 0, total: 0, limit: 0 };
        },
        
        /**
         * PHASE 3: Anomaly detection
         */
        _detectAnomalies(patternKey, newPattern) {
            const patterns = this._predictiveSystem.patterns.get(patternKey);
            if (patterns.length < 5) return; // Need baseline
            
            // Calculate baseline metrics
            const recentPatterns = patterns.slice(-10);
            const avgInterval = this._calculateAverageInterval(recentPatterns);
            const currentInterval = newPattern.timestamp - recentPatterns[recentPatterns.length - 2]?.timestamp;
            
            // Detect timing anomalies
            if (currentInterval > avgInterval * 3) {
                this._predictiveSystem.anomalies.push({
                    type: 'timing_anomaly',
                    pattern: patternKey,
                    severity: 'medium',
                    detected: Date.now(),
                    data: { expected: avgInterval, actual: currentInterval }
                });
                console.warn(`‚ö†Ô∏è PHASE 3: Timing anomaly detected for ${patternKey}`);
            }
        },
        
        /**
         * PHASE 3: Calculate average interval between events
         */
        _calculateAverageInterval(patterns) {
            if (patterns.length < 2) return 0;
            
            let totalInterval = 0;
            for (let i = 1; i < patterns.length; i++) {
                totalInterval += patterns[i].timestamp - patterns[i-1].timestamp;
            }
            return totalInterval / (patterns.length - 1);
        },
        
        /**
         * PHASE 3: Track event errors for analysis
         */
        _trackEventError(event, listener, error) {
            const errorData = {
                eventName: event.name,
                listenerId: listener.id,
                error: error.message,
                stack: error.stack,
                timestamp: Date.now(),
                context: this._getSystemContext()
            };
            
            // Update error rate
            this._systemHealth.metrics.errorRate++;
            
            // Add to anomalies if error rate is high
            if (this._systemHealth.metrics.errorRate > 10) {
                this._predictiveSystem.anomalies.push({
                    type: 'high_error_rate',
                    severity: 'high',
                    detected: Date.now(),
                    data: errorData
                });
            }
        },
        
        /**
         * PHASE 3: Update event performance metrics
         */
        _updateEventMetrics(eventName, duration) {
            // Update event latency tracking
            this._advancedEventBus.eventMetrics.eventLatency.push({
                event: eventName,
                duration,
                timestamp: Date.now()
            });
            
            // Keep only recent latency data
            if (this._advancedEventBus.eventMetrics.eventLatency.length > 100) {
                this._advancedEventBus.eventMetrics.eventLatency = this._advancedEventBus.eventMetrics.eventLatency.slice(-100);
            }
            
            // Calculate events per second
            const now = Date.now();
            const recentEvents = this._advancedEventBus.eventHistory.filter(e => now - e.timestamp < 1000);
            this._advancedEventBus.eventMetrics.eventsPerSecond = recentEvents.length;
        },
        
        /**
         * PHASE 3: Start real-time system health monitoring
         */
        _startSystemHealthMonitoring() {
            console.log('üìä PHASE 3: Starting real-time system health monitoring');
            
            this._systemHealth.status = 'monitoring';
            
            // Use requestAnimationFrame instead of setTimeout for smooth monitoring
            const healthCheck = () => {
                const now = performance.now();
                
                if (now - this._systemHealth.lastHealthCheck > this._systemHealth.healthCheckInterval) {
                    this._performHealthCheck();
                    this._systemHealth.lastHealthCheck = now;
                }
                
                // Continue monitoring
                requestAnimationFrame(healthCheck);
            };
            
            // Start monitoring loop
            requestAnimationFrame(healthCheck);
        },
        
        /**
         * PHASE 3: Perform comprehensive health check
         */
        _performHealthCheck() {
            const startTime = performance.now();
            
            // Update uptime
            this._systemHealth.uptime = Date.now() - this._systemHealth.startTime;
            
            // Update memory metrics
            const memoryInfo = this._getMemoryUsage();
            this._systemHealth.metrics.memoryUsage = memoryInfo.used / memoryInfo.total;
            
            // Update event throughput
            this._systemHealth.metrics.eventThroughput = this._advancedEventBus.eventMetrics.eventsPerSecond;
            
            // Calculate average response time
            const recentLatencies = this._advancedEventBus.eventMetrics.eventLatency.slice(-10);
            if (recentLatencies.length > 0) {
                const avgLatency = recentLatencies.reduce((sum, item) => sum + item.duration, 0) / recentLatencies.length;
                this._systemHealth.metrics.responseTime = avgLatency;
            }
            
            // Record health snapshot
            this._systemHealth.healthHistory.push({
                timestamp: Date.now(),
                metrics: { ...this._systemHealth.metrics },
                status: this._systemHealth.status
            });
            
            // Maintain health history size
            if (this._systemHealth.healthHistory.length > 200) {
                this._systemHealth.healthHistory = this._systemHealth.healthHistory.slice(-200);
            }
            
            // Check for health alerts
            this._checkHealthAlerts();
            
            // Track health check performance
            const checkDuration = performance.now() - startTime;
            if (checkDuration > 10) { // If health check takes more than 10ms
                console.warn(`‚ö†Ô∏è PHASE 3: Health check slow: ${checkDuration.toFixed(2)}ms`);
            }
        },
        
        /**
         * PHASE 3: Check for system health alerts
         */
        _checkHealthAlerts() {
            const alerts = [];
            const metrics = this._systemHealth.metrics;
            
            // Memory usage alert
            if (metrics.memoryUsage > 0.8) {
                alerts.push({
                    type: 'high_memory_usage',
                    severity: metrics.memoryUsage > 0.9 ? 'critical' : 'warning',
                    message: `Memory usage at ${(metrics.memoryUsage * 100).toFixed(1)}%`,
                    timestamp: Date.now()
                });
            }
            
            // Response time alert
            if (metrics.responseTime > 50) {
                alerts.push({
                    type: 'slow_response',
                    severity: metrics.responseTime > 100 ? 'critical' : 'warning',
                    message: `Slow response time: ${metrics.responseTime.toFixed(2)}ms`,
                    timestamp: Date.now()
                });
            }
            
            // Error rate alert
            if (metrics.errorRate > 5) {
                alerts.push({
                    type: 'high_error_rate',
                    severity: 'warning',
                    message: `High error rate: ${metrics.errorRate} errors`,
                    timestamp: Date.now()
                });
            }
            
            // Add new alerts
            alerts.forEach(alert => {
                this._systemHealth.alerts.push(alert);
                console.warn(`üö® PHASE 3: Health Alert [${alert.severity}]: ${alert.message}`);
            });
            
            // Maintain alerts history (keep last 50)
            if (this._systemHealth.alerts.length > 50) {
                this._systemHealth.alerts = this._systemHealth.alerts.slice(-50);
            }
        },
        
        /**
         * PHASE 3: Get real-time system dashboard data
         */
        getSystemDashboard() {
            return {
                health: {
                    status: this._systemHealth.status,
                    uptime: this._systemHealth.uptime,
                    metrics: { ...this._systemHealth.metrics },
                    alerts: this._systemHealth.alerts.slice(-10), // Last 10 alerts
                    score: this._calculateHealthScore()
                },
                performance: {
                    loadTimes: { ...this._performanceAnalytics.loadTimes },
                    eventMetrics: { ...this._advancedEventBus.eventMetrics },
                    benchmarks: {
                        avgEventDispatch: this._calculateAverageBenchmark('eventDispatch'),
                        avgStateUpdate: this._calculateAverageBenchmark('stateUpdates'),
                        avgRender: this._calculateAverageBenchmark('renders')
                    }
                },
                predictive: {
                    anomalies: this._predictiveSystem.anomalies.slice(-5),
                    patterns: this._predictiveSystem.patterns.size,
                    predictions: this._predictiveSystem.predictions.slice(-3)
                },
                systems: {
                    registered: Array.from(this._initializationState.systemsRegistered),
                    required: Array.from(this._initializationState.requiredSystems),
                    eventListeners: this._eventListeners.size,
                    queuedEvents: this._eventQueue.length
                }
            };
        },
        
        /**
         * PHASE 3: Calculate system health score (0-100)
         */
        _calculateHealthScore() {
            let score = 100;
            const metrics = this._systemHealth.metrics;
            
            // Deduct for high memory usage
            if (metrics.memoryUsage > 0.8) score -= 20;
            else if (metrics.memoryUsage > 0.6) score -= 10;
            
            // Deduct for slow response times
            if (metrics.responseTime > 100) score -= 30;
            else if (metrics.responseTime > 50) score -= 15;
            
            // Deduct for errors
            if (metrics.errorRate > 10) score -= 25;
            else if (metrics.errorRate > 5) score -= 10;
            
            // Deduct for low event throughput (if expected to be higher)
            if (metrics.eventThroughput < 1 && this._systemHealth.uptime > 5000) score -= 5;
            
            return Math.max(0, score);
        },
        
        /**
         * PHASE 3: Calculate average benchmark time
         */
        _calculateAverageBenchmark(benchmarkType) {
            const benchmarks = this._performanceAnalytics.benchmarks[benchmarkType];
            if (!benchmarks || benchmarks.length === 0) return 0;
            
            const recent = benchmarks.slice(-20); // Last 20 measurements
            const total = recent.reduce((sum, item) => sum + item.duration, 0);
            return total / recent.length;
        },
        
        /**
         * PHASE 3: Event replay system for debugging
         */
        replayEvents(fromTime, toTime = Date.now()) {
            const eventsToReplay = this._advancedEventBus.eventHistory.filter(event => 
                event.timestamp >= fromTime && event.timestamp <= toTime
            );
            
            console.log(`üîÑ PHASE 3: Replaying ${eventsToReplay.length} events from ${new Date(fromTime)} to ${new Date(toTime)}`);
            
            eventsToReplay.forEach((event, index) => {
                setTimeout(() => {
                    console.log(`üîÑ Replaying event ${index + 1}/${eventsToReplay.length}:`, event);
                    // Note: We don't actually re-dispatch to avoid side effects, just log
                }, index * 100); // 100ms delay between replays
            });
            
            return eventsToReplay;
        },
        
        // PHASE 3: Real-time System Health Monitoring
        _systemHealth: {
            status: 'initializing',
            uptime: 0,
            startTime: Date.now(),
            lastHealthCheck: 0,
            healthCheckInterval: 500, // 500ms for real-time monitoring
            metrics: {
                cpuUsage: 0,
                memoryUsage: 0,
                eventThroughput: 0,
                errorRate: 0,
                responseTime: 0
            },
            alerts: [],
            healthHistory: []
        },
        
        // PHASE 3: Performance Analytics
        _performanceAnalytics: {
            loadTimes: {
                domReady: 0,
                scriptsLoaded: 0,
                systemsReady: 0,
                fullyInitialized: 0
            },
            benchmarks: {
                eventDispatch: [],
                stateUpdates: [],
                renders: [],
                systemCalls: []
            },
            optimization: {
                eventBatching: true,
                lazyLoading: true,
                caching: true,
                preloading: true
            }
        },
        
        // PHASE 3: Predictive Failure Detection
        _predictiveSystem: {
            enabled: true,
            patterns: new Map(),
            anomalies: [],
            predictions: [],
            learningEnabled: true,
            confidenceThreshold: 0.7,
            preventionActions: new Map()
        },
        
        // System initialization state
        _initializationState: {
            coreReady: false,
            systemsRegistered: new Set(),
            requiredSystems: new Set(['EnhancedComponentManager', 'EnhancedStateManager', 'Renderer']),
            readyCallbacks: [],
            phase1Active: false,
            phase2Active: false,
            phase3Active: false,
            bulletproofMode: false,
            wordpressCoordinated: false,
            pureEventDriven: false,
            advancedMonitoring: false,
            ultimateMode: false
        },

        /**
         * Event Bus - Subscribe to events
         * @param {string} eventName - Event name to listen for
         * @param {function} callback - Function to call when event fires
         * @param {object} options - Optional configuration
         */
        subscribe(eventName, callback, options = {}) {
            if (typeof eventName !== 'string' || typeof callback !== 'function') {
                console.error('‚ùå GMKB.subscribe: Invalid parameters');
                return () => {};
            }

            if (!this._eventListeners.has(eventName)) {
                this._eventListeners.set(eventName, []);
            }

            const listener = {
                callback,
                once: options.once || false,
                priority: options.priority || 0,
                id: options.id || `listener_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
            };

            this._eventListeners.get(eventName).push(listener);
            
            // Sort by priority (higher priority = earlier execution)
            this._eventListeners.get(eventName).sort((a, b) => b.priority - a.priority);

            console.debug(`üì° GMKB: Subscribed to '${eventName}' (${listener.id})`);

            // Return unsubscribe function
            return () => this.unsubscribe(eventName, listener.id);
        },

        /**
         * Event Bus - Unsubscribe from events
         * @param {string} eventName - Event name
         * @param {string} listenerId - Listener ID to remove
         */
        unsubscribe(eventName, listenerId) {
            if (!this._eventListeners.has(eventName)) return false;

            const listeners = this._eventListeners.get(eventName);
            const index = listeners.findIndex(l => l.id === listenerId);
            
            if (index !== -1) {
                listeners.splice(index, 1);
                console.debug(`üì° GMKB: Unsubscribed from '${eventName}' (${listenerId})`);
                return true;
            }
            
            return false;
        },

        /**
         * PHASE 3: Advanced Event Bus - Enhanced dispatch with performance tracking
         * @param {string} eventName - Event name to dispatch
         * @param {*} data - Data to send with event
         * @param {object} options - Optional configuration
         */
        dispatch(eventName, data = {}, options = {}) {
            const startTime = performance.now();
            
            const event = {
                name: eventName,
                data,
                timestamp: Date.now(),
                source: options.source || 'unknown',
                id: `event_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                phase3: true
            };
            
            // PHASE 3: Event sourcing - record all events
            if (this._advancedEventBus.eventSourceEnabled) {
                this._recordEvent(event);
            }
            
            // PHASE 3: Predictive analysis
            this._analyzePredictivePattern(event);
            
            // If core systems aren't ready, queue the event
            if (!this._initializationState.coreReady && !options.immediate) {
                this._eventQueue.push(event);
                console.debug(`üì¨ GMKB: Queued event '${eventName}' (core not ready)`);
                return event.id;
            }

            const listeners = this._eventListeners.get(eventName);
            if (!listeners || listeners.length === 0) {
                console.debug(`üì° GMKB: No listeners for '${eventName}'`);
                return event.id;
            }

            console.debug(`üì¢ GMKB: Dispatching '${eventName}' to ${listeners.length} listeners`);

            // Execute listeners with performance tracking
            const listenersToRemove = [];
            listeners.forEach(listener => {
                const listenerStartTime = performance.now();
                try {
                    listener.callback(event);
                    
                    // PHASE 3: Track listener performance
                    const listenerTime = performance.now() - listenerStartTime;
                    this._performanceAnalytics.benchmarks.eventDispatch.push({
                        event: eventName,
                        listener: listener.id,
                        duration: listenerTime,
                        timestamp: Date.now()
                    });
                    
                    // Mark for removal if it's a one-time listener
                    if (listener.once) {
                        listenersToRemove.push(listener.id);
                    }
                } catch (error) {
                    console.error(`‚ùå GMKB: Error in event listener for '${eventName}':`, error);
                    
                    // PHASE 3: Track errors for predictive analysis
                    this._trackEventError(event, listener, error);
                }
            });

            // Remove one-time listeners
            listenersToRemove.forEach(id => {
                this.unsubscribe(eventName, id);
            });
            
            // PHASE 3: Update performance metrics
            const totalTime = performance.now() - startTime;
            this._updateEventMetrics(eventName, totalTime);
            
            return event.id;
        },

        /**
         * System Registration - Register a system instance
         * @param {string} systemName - Name of the system
         * @param {object} systemInstance - System instance
         */
        registerSystem(systemName, systemInstance) {
            if (!systemName || !systemInstance) {
                console.error('‚ùå GMKB: Invalid system registration parameters');
                return false;
            }

            // Store system instance
            this.systems[systemName] = systemInstance;
            this._initializationState.systemsRegistered.add(systemName);

            console.log(`‚úÖ GMKB: System registered - ${systemName}`);

            // Dispatch system registration event
            this.dispatch('core:system-registered', {
                systemName,
                systemInstance,
                registeredSystems: Array.from(this._initializationState.systemsRegistered)
            }, { immediate: true });

            // Check if all required systems are registered
            this._checkSystemsReady();

            return true;
        },

        /**
         * Check if all required systems are ready
         * @private
         */
        _checkSystemsReady() {
            const registeredSystems = this._initializationState.systemsRegistered;
            const requiredSystems = this._initializationState.requiredSystems;
            
            const allRequiredRegistered = Array.from(requiredSystems).every(
                system => registeredSystems.has(system)
            );

            if (allRequiredRegistered && !this._initializationState.coreReady) {
                this._initializationState.coreReady = true;
                
                console.log('üéâ GMKB: All core systems ready!');
                
                // Process queued events
                this._processEventQueue();
                
                // Dispatch core systems ready event
                this.dispatch('core:systems-ready', {
                    registeredSystems: Array.from(registeredSystems),
                    timestamp: Date.now()
                }, { immediate: true });

                // Execute ready callbacks
                this._initializationState.readyCallbacks.forEach(callback => {
                    try {
                        callback();
                    } catch (error) {
                        console.error('‚ùå GMKB: Error in ready callback:', error);
                    }
                });
                this._initializationState.readyCallbacks = [];
            }
        },

        /**
         * Process queued events
         * @private
         */
        _processEventQueue() {
            console.log(`üì¨ GMKB: Processing ${this._eventQueue.length} queued events`);
            
            const queuedEvents = [...this._eventQueue];
            this._eventQueue = [];

            queuedEvents.forEach(event => {
                this.dispatch(event.name, event.data, { 
                    immediate: true, 
                    source: event.source 
                });
            });
        },

        /**
         * Wait for core systems to be ready
         * @param {function} callback - Function to call when ready
         */
        ready(callback) {
            if (typeof callback !== 'function') {
                console.error('‚ùå GMKB.ready: Callback must be a function');
                return;
            }

            if (this._initializationState.coreReady) {
                // Already ready, execute immediately
                callback();
            } else {
                // Queue for later execution
                this._initializationState.readyCallbacks.push(callback);
            }
        },

        /**
         * Get system status for debugging
         */
        getStatus() {
            return {
                coreReady: this._initializationState.coreReady,
                registeredSystems: Array.from(this._initializationState.systemsRegistered),
                requiredSystems: Array.from(this._initializationState.requiredSystems),
                queuedEvents: this._eventQueue.length,
                eventListeners: Object.fromEntries(
                    Array.from(this._eventListeners.entries()).map(([event, listeners]) => [
                        event, 
                        listeners.length
                    ])
                ),
                systems: Object.keys(this.systems),
                version: '3.0.0-phase3-ultimate-pure-event-driven',
                phase3Active: this._initializationState.phase3Active,
                ultimateMode: this._initializationState.ultimateMode,
                pureEventDriven: this._initializationState.pureEventDriven,
                advancedMonitoring: this._initializationState.advancedMonitoring,
                systemHealth: this._systemHealth,
                performanceAnalytics: this._performanceAnalytics,
                predictiveSystem: {
                    enabled: this._predictiveSystem.enabled,
                    patterns: this._predictiveSystem.patterns.size,
                    anomalies: this._predictiveSystem.anomalies.length
                },
                eventBusMetrics: this._advancedEventBus.eventMetrics,
                rootFixApplied: true,
                initTime: window.gmkbInitTime || Date.now()
            };
        },

        /**
         * PHASE 3: Enhanced WordPress event integration with ultimate coordination
         */
        initWordPressEvents() {
            if (this._wordpressEvents && this._wordpressEvents.ready) return;
            
            console.log('üöÄ PHASE 3: Initializing ULTIMATE WordPress event integration with advanced monitoring...');
            
            // PHASE 3: Set ultimate mode flags
            this._initializationState.phase3Active = true;
            this._initializationState.ultimateMode = true;
            this._initializationState.pureEventDriven = true;
            this._initializationState.advancedMonitoring = true;
            
            // PHASE 3: Start advanced monitoring systems
            this._startSystemHealthMonitoring();
            
            // PHASE 3: Initialize performance tracking
            this._performanceAnalytics.loadTimes.domReady = performance.now();
            
            // Record initialization milestone
            this.dispatch('phase3:initialization-start', {
                timestamp: Date.now(),
                performanceStart: window.gmkbPhase3StartTime,
                ultimateMode: true
            }, { immediate: true });
            
            console.log('‚úÖ PHASE 3: Ultimate WordPress event integration initialized with real-time monitoring');
        },
        
        /**
         * PHASE 2: WordPress action hook system integration
         */
        initWordPressActionHooks() {
            if (!window.gmkbWordPressHooks) {
                console.warn('‚ö†Ô∏è PHASE 2: WordPress action hooks not available');
                return;
            }
            
            console.log('üîó PHASE 2: Integrating with WordPress action hook system');
            
            // Listen for WordPress action hooks
            window.gmkbWordPressHooks.add('wordpress-ready', (data) => {
                console.log('‚úÖ PHASE 2: WordPress action hook - wordpress-ready');
                this._initializationState.wordpressCoordinated = true;
            });
            
            window.gmkbWordPressHooks.add('scripts-validation-start', (data) => {
                console.log('üîç PHASE 2: WordPress action hook - scripts-validation-start');
                this.validateScriptsWithIntegrity(data.expectedScripts || []);
            });
            
            // Register GMKB events with WordPress hooks
            this.subscribe('core:namespace-ready', (event) => {
                if (window.gmkbWordPressHooks) {
                    window.gmkbWordPressHooks.dispatch('gmkb-namespace-ready', event.data);
                }
            });
            
            this.subscribe('core:systems-ready', (event) => {
                if (window.gmkbWordPressHooks) {
                    window.gmkbWordPressHooks.dispatch('gmkb-systems-ready', event.data);
                }
            });
            
            console.log('‚úÖ PHASE 2: WordPress action hook integration completed');
        },
        
        /**
         * PHASE 2: Enhanced script validation with integrity checking
         */
        validateScriptsWithIntegrity(expectedScripts) {
            const foundScripts = [];
            const missingScripts = [];
            const corruptedScripts = [];
            
            expectedScripts.forEach(scriptConfig => {
                const scriptName = scriptConfig.handle || scriptConfig;
                const scriptElement = document.querySelector(`script[data-gmkb-script="${scriptName}"]`);
                
                if (scriptElement) {
                    // PHASE 2: Enhanced integrity checking
                    const priority = scriptElement.getAttribute('data-gmkb-priority');
                    const phase = scriptElement.getAttribute('data-gmkb-phase');
                    
                    if (phase === '2' && priority) {
                        foundScripts.push({
                            handle: scriptName,
                            priority: parseInt(priority),
                            integrity: 'verified',
                            phase: 2
                        });
                    } else {
                        corruptedScripts.push({
                            handle: scriptName,
                            issue: 'missing-phase2-attributes'
                        });
                    }
                } else {
                    missingScripts.push(scriptName);
                }
            });
            
            console.log('üìã PHASE 2: Enhanced script validation results:');
            console.log('  ‚úÖ Found with integrity:', foundScripts);
            
            if (missingScripts.length > 0) {
                console.warn('  ‚ùå Missing:', missingScripts);
            }
            
            if (corruptedScripts.length > 0) {
                console.warn('  üõ†Ô∏è Corrupted:', corruptedScripts);
                this._namespaceIntegrity.corruptionDetected = true;
            }
            
            // PHASE 2: Dispatch enhanced validation results
            this.dispatch('gmkb:scripts-validated', {
                found: foundScripts,
                missing: missingScripts,
                corrupted: corruptedScripts,
                allFound: missingScripts.length === 0,
                integrityValid: corruptedScripts.length === 0,
                phase2: true
            });
            
            // WordPress action hook dispatch
            if (window.gmkbWordPressHooks) {
                window.gmkbWordPressHooks.dispatch('scripts-validation-complete', {
                    foundCount: foundScripts.length,
                    missingCount: missingScripts.length,
                    corruptedCount: corruptedScripts.length
                });
            }
        },
        
        /**
         * PHASE 2: Circuit breaker failure handler
         */
        _handleCircuitBreakerFailure(operation, error) {
            console.error(`‚ùå PHASE 2: Circuit breaker - ${operation} failed:`, error);
            
            const breaker = this._wordpressEvents.circuitBreaker;
            breaker.failures++;
            breaker.lastFailureTime = Date.now();
            
            if (breaker.failures >= breaker.threshold) {
                breaker.isOpen = true;
                console.warn(`üö® PHASE 2: Circuit breaker OPEN for ${operation} - entering recovery mode`);
                
                // Attempt graceful recovery after timeout
                setTimeout(() => {
                    this._attemptCircuitBreakerRecovery(operation);
                }, breaker.recoveryTimeout);
            }
        },
        
        /**
         * PHASE 2: Circuit breaker recovery attempt
         */
        _attemptCircuitBreakerRecovery(operation) {
            console.log(`üîÑ PHASE 2: Attempting circuit breaker recovery for ${operation}`);
            
            const breaker = this._wordpressEvents.circuitBreaker;
            
            // Test recovery by attempting a simple operation
            try {
                // Simple validation that systems are responding
                const testEvent = { test: true, timestamp: Date.now() };
                this.dispatch('test:circuit-breaker-recovery', testEvent, { immediate: true });
                
                // If we get here, recovery successful
                breaker.isOpen = false;
                breaker.failures = 0;
                console.log(`‚úÖ PHASE 2: Circuit breaker recovery successful for ${operation}`);
                
            } catch (error) {
                console.error(`‚ùå PHASE 2: Circuit breaker recovery failed for ${operation}:`, error);
                
                // Schedule another recovery attempt
                setTimeout(() => {
                    this._attemptCircuitBreakerRecovery(operation);
                }, breaker.recoveryTimeout * 2); // Exponential backoff
            }
        },
        
        /**
         * PHASE 2: Enhanced event queue processing with safety
         */
        _processEventQueueSafely() {
            console.log(`üì¨ PHASE 2: Safely processing ${this._eventQueue.length} queued events`);
            
            const queuedEvents = [...this._eventQueue];
            this._eventQueue = [];
            
            queuedEvents.forEach(event => {
                try {
                    this.dispatch(event.name, event.data, { 
                        immediate: true, 
                        source: event.source,
                        safeMode: true
                    });
                } catch (error) {
                    console.error(`‚ùå PHASE 2: Error processing queued event ${event.name}:`, error);
                    this._handleCircuitBreakerFailure('event-processing', error);
                }
            });
        },
        
        /**
         * PHASE 2: Namespace integrity monitoring
         */
        _startNamespaceIntegrityMonitoring() {
            console.log('üõ°Ô∏è PHASE 2: Starting namespace integrity monitoring');
            
            const monitor = () => {
                try {
                    const now = Date.now();
                    if (now - this._namespaceIntegrity.lastCheck < this._namespaceIntegrity.checkInterval) {
                        return;
                    }
                    
                    this._namespaceIntegrity.lastCheck = now;
                    
                    // Check for namespace corruption
                    const validation = this.validateIntegrity();
                    
                    if (!validation.valid && !this._namespaceIntegrity.corruptionDetected) {
                        console.warn('üö® PHASE 2: Namespace corruption detected:', validation.issues);
                        this._namespaceIntegrity.corruptionDetected = true;
                        this._attemptNamespaceRestoration();
                    }
                    
                } catch (error) {
                    console.error('‚ùå PHASE 2: Error during integrity monitoring:', error);
                }
                
                // Schedule next check
                setTimeout(monitor, this._namespaceIntegrity.checkInterval);
            };
            
            // Start monitoring
            setTimeout(monitor, this._namespaceIntegrity.checkInterval);
        },
        
        /**
         * PHASE 2: Namespace restoration attempt
         */
        _attemptNamespaceRestoration() {
            if (this._namespaceIntegrity.restorationAttempts >= this._namespaceIntegrity.maxRestorationAttempts) {
                console.error('‚ùå PHASE 2: Maximum namespace restoration attempts exceeded');
                return;
            }
            
            this._namespaceIntegrity.restorationAttempts++;
            console.log(`üîÑ PHASE 2: Attempting namespace restoration (attempt ${this._namespaceIntegrity.restorationAttempts})`);
            
            try {
                // Restore critical methods if they're missing
                const criticalMethods = ['subscribe', 'dispatch', 'ready', 'registerSystem'];
                
                criticalMethods.forEach(methodName => {
                    if (typeof this[methodName] !== 'function') {
                        console.warn(`üîß PHASE 2: Restoring critical method: ${methodName}`);
                        // Would need to restore from a backup or rebuild
                        // For now, flag the corruption
                        throw new Error(`Critical method ${methodName} is corrupted`);
                    }
                });
                
                // If we get here, restoration successful
                this._namespaceIntegrity.corruptionDetected = false;
                console.log('‚úÖ PHASE 2: Namespace restoration successful');
                
            } catch (error) {
                console.error('‚ùå PHASE 2: Namespace restoration failed:', error);
                
                // Trigger complete recovery as last resort
                this.forceRecovery();
            }
        },
        
        /**
         * PHASE 2: Enhanced debug with bulletproof coordination status
         */
        debug() {
            console.group('%cüèóÔ∏è PHASE 1: GMKB Core System Debug', 'font-size: 16px; font-weight: bold; color: #2563eb');
            
            const status = this.getStatus();
            console.log('üìä Status:', status);
            
            // PHASE 1: WordPress integration status
            console.log('üéØ WordPress Integration:', this._wordpressEvents);
            
            // PHASE 1: Validation check
            const validation = this.validateIntegrity();
            console.log('üîç Integrity Check:', validation);
            
            if (status.queuedEvents > 0) {
                console.log('üì¨ Queued Events:', this._eventQueue);
            }
            
            if (this._eventListeners.size > 0) {
                console.log('üì° Event Listeners:');
                this._eventListeners.forEach((listeners, eventName) => {
                    console.log(`  ${eventName}: ${listeners.length} listeners`);
                });
            }
            
            if (Object.keys(this.systems).length > 0) {
                console.log('üîß Registered Systems:', Object.keys(this.systems));
            }
            
            console.groupEnd();
        },
        
        /**
         * ROOT FIX: Validate GMKB integrity
         */
        validateIntegrity() {
            const issues = [];
            
            // Check core methods
            if (typeof this.subscribe !== 'function') issues.push('subscribe method missing');
            if (typeof this.dispatch !== 'function') issues.push('dispatch method missing');
            if (typeof this.ready !== 'function') issues.push('ready method missing');
            if (typeof this.registerSystem !== 'function') issues.push('registerSystem method missing');
            
            // Check data structures
            if (!this._eventListeners) issues.push('_eventListeners missing');
            if (!this._eventQueue) issues.push('_eventQueue missing');
            if (!this._initializationState) issues.push('_initializationState missing');
            if (!this.systems) issues.push('systems object missing');
            
            return {
                valid: issues.length === 0,
                issues: issues,
                timestamp: Date.now()
            };
        },
        
        /**
         * PHASE 1: Force recovery from corrupted state (WordPress-coordinated)
         */
        forceRecovery() {
            console.warn('‚ö†Ô∏è PHASE 1: Forcing GMKB recovery...');
            
            try {
                // Reset core data structures
                this._eventListeners = new Map();
                this._eventQueue = [];
                this.systems = {};
                this._initializationState = {
                    coreReady: false,
                    systemsRegistered: new Set(),
                    requiredSystems: new Set(['EnhancedStateManager', 'Renderer', 'EnhancedComponentManager']),
                    readyCallbacks: [],
                    phase1Active: false
                };
                
                // Reset WordPress event integration
                this._wordpressEvents = {
                    ready: false,
                    scriptsValidated: false,
                    listeners: new Map()
                };
                
                // Re-initialize WordPress events
                this.initWordPressEvents();
                
                console.log('‚úÖ PHASE 1: GMKB recovery completed with WordPress integration');
                return true;
                
            } catch (error) {
                console.error('‚ùå PHASE 1: GMKB recovery failed:', error);
                return false;
            }
        }
    };

    // PHASE 1: WordPress-native global exposure with namespace protection
    try {
        // PHASE 1: Initialize WordPress events first
        GMKB.initWordPressEvents();
        
        // PHASE 1: Freeze core methods to prevent corruption
        Object.freeze(GMKB.subscribe);
        Object.freeze(GMKB.dispatch);
        Object.freeze(GMKB.ready);
        Object.freeze(GMKB.registerSystem);
        
        // PHASE 1: Expose globally with namespace protection
        Object.defineProperty(window, 'GMKB', {
            value: GMKB,
            writable: false,
            configurable: false
        });
        
        // PHASE 1: Enhanced readiness flags
        window.gmkbCoreReady = true;
        window.gmkbInitTime = Date.now();
        window.gmkbPhase1Active = true;
        
        // PHASE 1: Immediate validation
        if (!window.GMKB || !window.GMKB.dispatch || !window.GMKB.ready) {
            throw new Error('GMKB namespace incomplete after initialization');
        }
        
        console.log('‚úÖ PHASE 1: GMKB namespace exposed with corruption protection');
        
        // PHASE 1: WordPress event-driven initialization
        const dispatchNamespaceReady = () => {
            try {
                // Mark phase 1 as active
                GMKB._initializationState.phase1Active = true;
                
                GMKB.dispatch('core:namespace-ready', {
                    timestamp: Date.now(),
                    readyState: document.readyState,
                    initTime: window.gmkbInitTime,
                    phase1Active: true,
                    wordpressIntegrated: true,
                    namespaceFrozen: true
                }, { immediate: true });
                
                console.log('‚úÖ PHASE 1: core:namespace-ready event dispatched with WordPress integration');
            } catch (error) {
                console.error('‚ùå PHASE 1: Error dispatching namespace-ready event:', error);
            }
        };
        
        // PHASE 1: Event-driven dispatch (no timeouts)
        if (document.readyState === 'complete' || document.readyState === 'interactive') {
            // DOM is ready, dispatch immediately
            dispatchNamespaceReady();
        } else {
            // Wait for DOM without polling
            document.addEventListener('DOMContentLoaded', dispatchNamespaceReady, { once: true });
        }
        
        console.log('üèóÔ∏è PHASE 1: GMKB Core Namespace initialized with WordPress integration');
        
    } catch (error) {
        console.error('‚ùå PHASE 1: CRITICAL ERROR during GMKB initialization:', error);
        console.error('‚ùå PHASE 1: Stack trace:', error.stack);
        
        // PHASE 1: Emergency fallback with WordPress integration
        if (!window.GMKB) {
            window.GMKB = {
                error: error.message,
                timestamp: Date.now(),
                fallbackMode: true,
                emergencyFallback: true,
                phase1Failed: true
            };
            console.warn('‚ö†Ô∏è PHASE 1: Emergency GMKB fallback created');
        }
        
        // Re-throw to maintain error visibility
        throw error;
    }
    
    console.log('üéâ PHASE 3: gmkb-main.js execution completed with ULTIMATE pure event-driven architecture, real-time monitoring, and predictive analytics');

})(window);
